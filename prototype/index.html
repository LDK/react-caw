<html>
<head>
	<script src="./build/spine-webgl.js"></script>
	<link rel="stylesheet" href="bootstrap.min.css">
</head>()
<style>
* { margin: 0; padding: 0; }
body, html { height: 100%;}
body {
	background: rgb(2,0,36);
	background: -moz-linear-gradient(121deg, rgba(2,0,36,1) 0%, rgba(2,0,36,1) 11%, rgba(37,105,201,1) 43%, rgba(37,80,201,1) 68%, rgba(243,255,0,0.99) 91%, rgba(243,255,0,1) 100%);
	background: -webkit-linear-gradient(121deg, rgba(2,0,36,1) 0%, rgba(2,0,36,1) 11%, rgba(37,105,201,1) 43%, rgba(37,80,201,1) 68%, rgba(243,255,0,0.99) 91%, rgba(243,255,0,1) 100%);
	background: linear-gradient(121deg, rgba(2,0,36,1) 0%, rgba(2,0,36,1) 11%, rgba(37,105,201,1) 43%, rgba(37,80,201,1) 68%, rgba(243,255,0,0.99) 91%, rgba(243,255,0,1) 100%);
	filter: progid:DXImageTransform.Microsoft.gradient(startColorstr="#020024",endColorstr="#f3ff00",GradientType=1);
}
canvas { 
	transform: scaleX(-1);
	position: relative; 
	width: 100%;
	height: 364px; 
	backdrop-filter: blur(4px);
	background-color: transparent;
/*	mix-blend-mode: color-burn;*/
}
#app-wrapper {
	height: 80%;
	position: relative;
	top: 10%;
}
@media (max-width:575px) {
	
}
@media (min-width:576px) {
	
}
@media (min-width:768px) {
	
}
@media (min-width:992px) {
	canvas { 
		border: 1px solid black;
		height: 424px; 
	}	
}
@media (min-width:1200px) {
	canvas { 
		height: 464px; 
	}	
}
@media (min-width:1800px) {
}
</style>
<body>
<!-- <div style="position:relative;top:2rem;z-index:1;">
	<a href="javascript:;" style="margin-left: 2rem; padding: 1rem 1.5rem; background: #FAFAFA; border-radius: 15%">a button!</a>
</div> -->
	<div id="app-wrapper" class="container-fluid">
		<div class="row">
			<div class="col-12 col-md-6 col-xl-7">
			</div>
			<div class="col-12 col-md-6 col-xl-5">
				<canvas id="canvas"></canvas>
			</div>
		</div>
	</div>
<script>

var canvas;
var gl;
var shader;
var batcher;
var mvp = new spine.webgl.Matrix4();
var assetManager;
var skeletonRenderer;

var lastFrameTime;
var figure;
const character = {
	defaultAnim: 'idle',
	skelFile: "assets/Wrestler-pro.skel",
	atlasFile: "assets/Wrestler-pma.atlas",
	skin: 'Male Wrestler'
};

function init () {
	// Setup canvas and WebGL context. We pass alpha: false to canvas.getContext() so we don't use premultiplied alpha when
	// loading textures. That is handled separately by PolygonBatcher.
	canvas = document.getElementById("canvas");
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
	var config = { alpha: true };
	gl = canvas.getContext("webgl", config) || canvas.getContext("experimental-webgl", config);
	if (!gl) {
		alert('WebGL is unavailable.');
		return;
	}

	// Create a simple shader, mesh, model-view-projection matrix, SkeletonRenderer, and AssetManager.
	shader = spine.webgl.Shader.newTwoColoredTextured(gl);
	batcher = new spine.webgl.PolygonBatcher(gl);
	mvp.ortho2d(0, 0, canvas.width - 1, canvas.height - 1);
	skeletonRenderer = new spine.webgl.SkeletonRenderer(gl);
	assetManager = new spine.webgl.AssetManager(gl);

	// Tell AssetManager to load the resources for each skeleton, including the exported .skel file, the .atlas file and the .png
	// file for the atlas. We then wait until all resources are loaded in the load() method.
	assetManager.loadBinary(character.skelFile);
	assetManager.loadTextureAtlas(character.atlasFile);
	requestAnimationFrame(loadSkeleton);
}

function setSlotColor(skeleton,slotName,color) {
	var slotColor = skeleton.findSlot(slotName).color;
	slotColor.r = color.r;
	slotColor.g = color.g;
	slotColor.b = color.b;
	slotColor.a = color.a;
}

const skinSlots = ["Head","Nose"];

function setSkinColor(skeleton,color) {
	for (var i in skinSlots) {
		setSlotColor(skeleton,skinSlots[i],color);
	}
}

function loadSkeleton () {
	// Wait until the AssetManager has loaded all resources, then load the skeletons.
	if (assetManager.isLoadingComplete()) {
		figure = loadFigure(character.defaultAnim, true);
		// console.log('figure',figure);
		setSkinColor(figure.skeleton,{ r: .85, g: .75, b: .7, a: 1});
		lastFrameTime = Date.now() / 1000;
		requestAnimationFrame(renderFigure); // Loading is done, call render every frame.
	} else {
		requestAnimationFrame(loadSkeleton);
	}
}

function loadFigure (initialAnimation, premultipliedAlpha) {
	// Load the texture atlas from the AssetManager.
	var atlas = assetManager.get(character.atlasFile);

	// Create a AtlasAttachmentLoader that resolves region, mesh, boundingbox and path attachments
	var atlasLoader = new spine.AtlasAttachmentLoader(atlas);

	// Create a SkeletonBinary instance for parsing the .skel file.
	var skeletonBinary = new spine.SkeletonBinary(atlasLoader);

	// Set the scale to apply during parsing, parse the file, and create a new skeleton.
	skeletonBinary.scale = 1;
	var skeletonData = skeletonBinary.readSkeletonData(assetManager.get(character.skelFile));
	console.log('animations',skeletonData.animations);
	if (!initialAnimation) {
		initialAnimation = skeletonData.animations[0].name;
	}
	var skeleton = new spine.Skeleton(skeletonData);
	if (character.skin) {
		skeleton.setSkinByName(character.skin);
	}
	var bounds = calculateSetupPoseBounds(skeleton);

	// Create an AnimationState, and set the initial animation in looping mode.
	var animationStateData = new spine.AnimationStateData(skeleton.data);
	var animationState = new spine.AnimationState(animationStateData);
	animationState.setAnimation(0, initialAnimation, true);
	

	// Pack everything up and return to caller.
	return { skeleton: skeleton, state: animationState, bounds: bounds, premultipliedAlpha: premultipliedAlpha };
}

function calculateSetupPoseBounds (skeleton) {
	skeleton.setToSetupPose();
	skeleton.updateWorldTransform();
	var offset = new spine.Vector2();
	var size = new spine.Vector2();
	skeleton.getBounds(offset, size, []);
	return { offset: offset, size: size };
}
function renderFigure () {
	var now = Date.now() / 1000;
	var delta = now - lastFrameTime;
	lastFrameTime = now;

	// Update the MVP matrix to adjust for canvas size changes
	resize();

	gl.clearColor(0.3, 0.3, 0.3, .4);
	gl.clear(gl.COLOR_BUFFER_BIT);

	// Apply the animation state based on the delta time.
	var skeleton = figure.skeleton;
	var state = figure.state;
	var premultipliedAlpha = figure.premultipliedAlpha;
	state.update(delta);
	state.apply(skeleton);
	skeleton.updateWorldTransform();

	// Bind the shader and set the texture and model-view-projection matrix.
	shader.bind();
	shader.setUniformi(spine.webgl.Shader.SAMPLER, 0);
	shader.setUniform4x4f(spine.webgl.Shader.MVP_MATRIX, mvp.values);

	// Start the batch and tell the SkeletonRenderer to render the active skeleton.
	batcher.begin(shader);
	skeletonRenderer.premultipliedAlpha = premultipliedAlpha;
	skeletonRenderer.draw(batcher, skeleton);
	batcher.end();

	shader.unbind();

	requestAnimationFrame(renderFigure);
}

function resize () {
	var w = canvas.clientWidth;
	var h = canvas.clientHeight;
	if (canvas.width != w || canvas.height != h) {
		canvas.width = w;
		canvas.height = h;
	}

	// Calculations to center the skeleton in the canvas.
	var bounds = figure.bounds;
	var centerX = bounds.offset.x + bounds.size.x / 2;
	var centerY = bounds.offset.y + bounds.size.y / 2;
	var scaleX = bounds.size.x / canvas.width;
	var scaleY = bounds.size.y / canvas.height;
	var scale = Math.max(scaleX, scaleY) * 1.2;
	if (scale < 1) scale = 1;
	var width = canvas.width * scale;
	var height = canvas.height * scale;

	mvp.ortho2d(centerX - width / 2, centerY - height / 2, width, height);
	gl.viewport(0, 0, canvas.width, canvas.height);
}

init();

</script>
</body>
</html>